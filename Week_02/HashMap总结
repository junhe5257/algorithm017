HashMap是一种键值对的存储形式，每一个key对应唯一的value，允许null值但只能存在一个为null的key。
HashMap的底层实现是数组+链表(红黑树)，在新增时，会对key值进行哈希运算，根据得到的哈希值判断是否
已经存在相同哈希值的key(即哈希冲突)，如果产生哈希冲突，会用拉链法解决，即在同一个数组下标下展开一个
链表，当链表长度大于等于8时，链表会转换为红黑树，小于8时又会变回链表。
HashMap的初始大小为16，负载因子为0.75，即大于12时进行扩容，每次扩容将大小提升至2倍。负载因子默认
0.75的原因是，如果负载因子过小(例如0.5)则大幅度降低了空间利用率，如果负载因子过大(例如1)则增加了查询
时间成本，0.75符合泊松分布，是时间和空间上的一种折中选择。
HashMap是线程不安全的，在并发环境下，如果产生哈希冲突，则拉链法中的链表构造可能会出现问题，在并发环境
下我们可以选择HashTable或ConcurrentHashMap，HashTable是一种比较过时的散列表，它只是在HashMap的
基础上对很多方法添加了synchronized关键字，这种悲观重量级锁的实现会大幅度降低效率。而ConcurrentHashMap
采用了Segment分段锁，在整个ConcurrentHashMap中使用共16把锁对局部加锁，从而兼顾了线程安全与效率。